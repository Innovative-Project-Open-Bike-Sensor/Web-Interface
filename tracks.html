<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tracks</title>
  <link rel="stylesheet" href="assets/css/style.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    .trace-item-container {
      margin-bottom: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .trace-item, .download-item {
      padding: 6px 12px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
    }
    .trace-item {
      background-color: #2563eb;
      color: white;
    }
    .download-item {
      background-color: #10b981;
      color: white;
    }
    .download-item.csv {
      background-color: #6b7280;
    }
  </style>
</head>
<body class="iframe-page">
<div id="container">
  <div id="trace-list">
    <h3>Tracks</h3>
    <div id="list"></div>
  </div>
  <div id="map"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const API_URL = "https://lilied-subprofessionally-mafalda.ngrok-free.dev/api/measurements";
const API_KEY = "openbikecle";
const MAX_GAP_SECONDS = 5;

const map = L.map("map").setView([43.6001, 1.4419], 13);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { attribution: "Â© OpenStreetMap" }).addTo(map);

let currentLayer = null;
let currentMarkers = null;

function toTimestamp(p) { return new Date(p.year, p.month - 1, p.day, p.hour, p.minute, p.second).getTime(); }

function groupIntoTraces(points, maxGapSeconds) {
  const traces = [];
  let current = [];
  const sorted = [...points].sort((a,b) => toTimestamp(a) - toTimestamp(b));
  for (let i=0; i<sorted.length; i++) {
    if (current.length === 0) { current.push(sorted[i]); continue; }
    const gap = (toTimestamp(sorted[i]) - toTimestamp(current[current.length-1]))/1000;
    if (gap > maxGapSeconds) { traces.push(current); current = []; }
    current.push(sorted[i]);
  }
  if (current.length) traces.push(current);
  return traces;
}

function showTrace(trace) {
  if (currentLayer) {
    map.removeLayer(currentLayer);
  }
  if (currentMarkers) {
    currentMarkers.forEach(marker => map.removeLayer(marker));
  }

  const coords = trace.map(p => [p.lat, p.lng]);
  currentLayer = L.polyline(coords, {
    color: "#2563eb",
    weight: 4
  }).addTo(map);

  currentMarkers = trace.map(p => {
    const marker = L.circleMarker([p.lat, p.lng], {
      radius: 7,
      fillColor: "#2563eb",
      color: "#000",
      weight: 1,
      opacity: 1,
      fillOpacity: 0.8,
      className: 'trace-marker'
    }).addTo(map);

    marker.bindPopup(`
      <strong>Date</strong> : ${p.day}/${p.month}/${p.year}<br>
      <strong>Heure</strong> : ${p.hour}:${p.minute}:${p.second}<br>
      <strong>Vitesse</strong> : ${p.speed_kmh ? p.speed_kmh.toFixed(1) : 'N/A'} km/h<br>
      <strong>Distance</strong> : ${p.distanceMin_cm ? p.distanceMin_cm : 'N/A'} cm
    `);

    return marker;
  });

  map.fitBounds(currentLayer.getBounds());
}

function downloadTraceAsJson(trace, filename) {
  const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(trace, null, 2));
  const downloadAnchorNode = document.createElement('a');
  downloadAnchorNode.setAttribute("href", dataStr);
  downloadAnchorNode.setAttribute("download", filename + ".json");
  document.body.appendChild(downloadAnchorNode);
  downloadAnchorNode.click();
  downloadAnchorNode.remove();
}

function downloadTraceAsCsv(trace, filename) {
  // Convert trace to CSV format
  let csv = "lat,lng,day,month,year,hour,minute,second,speed_kmh,distanceMin_cm\n";
  trace.forEach(point => {
    csv += `${point.lat},${point.lng},${point.day},${point.month},${point.year},${point.hour},${point.minute},${point.second},${point.speed_kmh || 'N/A'},${point.distanceMin_cm || 'N/A'}\n`;
  });

  const dataStr = "data:text/csv;charset=utf-8," + encodeURIComponent(csv);
  const downloadAnchorNode = document.createElement('a');
  downloadAnchorNode.setAttribute("href", dataStr);
  downloadAnchorNode.setAttribute("download", filename + ".csv");
  document.body.appendChild(downloadAnchorNode);
  downloadAnchorNode.click();
  downloadAnchorNode.remove();
}

async function loadTraces() {
  try {
    const response = await fetch(API_URL, { headers: { "X-API-KEY": API_KEY, "ngrok-skip-browser-warning": "true" } });
    let data = await response.json();
    data = data.filter(p => p.valid === 1);
    const traces = groupIntoTraces(data, MAX_GAP_SECONDS);
    const list = document.getElementById("list");
    list.innerHTML = "";

    traces.forEach((trace, index) => {
      const div = document.createElement("div");
      div.className = "trace-item-container";

      const btn = document.createElement("button");
      btn.className = "trace-item";
      btn.innerText = `${trace[0].day}/${trace[0].month} - ${trace.length} pts`;
      btn.onclick = () => showTrace(trace);

      const downloadJsonBtn = document.createElement("button");
      downloadJsonBtn.className = "download-item";
      downloadJsonBtn.innerText = "Download JSON";
      downloadJsonBtn.onclick = () => downloadTraceAsJson(trace, `trace_${index}`);

      const downloadCsvBtn = document.createElement("button");
      downloadCsvBtn.className = "download-item csv";
      downloadCsvBtn.innerText = "Download CSV";
      downloadCsvBtn.onclick = () => downloadTraceAsCsv(trace, `trace_${index}`);

      div.appendChild(btn);
      div.appendChild(downloadJsonBtn);
      div.appendChild(downloadCsvBtn);
      list.appendChild(div);
    });
  } catch(err) { console.error(err); }
}

window.addEventListener('message', (event) => {
  if (event.data.action === 'refreshData') {
    loadTraces();
  }
});

loadTraces();
</script>
</body>
</html>
